//===- BlockHandler.cpp - Unified Block Handler Implementation ------------===//
//
// This file implements the unified block handler with producer-responsible
// FIFO coordination for all control flow structures
//
//===----------------------------------------------------------------------===//

#include "APS/BlockHandler.h"
#include "APS/BBHandler.h"
#include "APS/LoopHandler.h"
#include "APS/APSOps.h"
#include "TOR/TOR.h"
#include "circt/Dialect/Cmt2/ECMT2/SignalHelpers.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/IR/Block.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/Value.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/LogicalResult.h"
#include "llvm/Support/raw_ostream.h"

namespace mlir {

using namespace mlir;
using namespace mlir::tor;
using namespace circt::cmt2::ecmt2;
using namespace circt::cmt2::ecmt2::stl;
using namespace circt::firrtl;

//===----------------------------------------------------------------------===//
// BlockHandler Implementation
//===----------------------------------------------------------------------===//

BlockHandler::BlockHandler(APSToCMT2GenPass *pass, Module *mainModule, tor::FuncOp funcOp,
                          Instance *poolInstance, Instance *roccInstance,
                          Instance *hellaMemInstance, InterfaceDecl *dmaItfc,
                          Circuit &circuit, Clock mainClk, Reset mainRst,
                          unsigned long opcode, Instance *regRdInstance,
                          Instance *inputTokenFIFO, Instance *outputTokenFIFO,
                          llvm::DenseMap<Value, Instance*> &input_fifos,
                          llvm::DenseMap<Value, Instance*> &output_fifos,
                          const std::string &namePrefix)
    : pass(pass), mainModule(mainModule), funcOp(funcOp), poolInstance(poolInstance),
      roccInstance(roccInstance), hellaMemInstance(hellaMemInstance), regRdInstance(regRdInstance),
      dmaItfc(dmaItfc), circuit(circuit), mainClk(mainClk), mainRst(mainRst), opcode(opcode),
      namePrefix(namePrefix.empty() ? "inst" + std::to_string(opcode) + "_" : namePrefix),
      inputTokenFIFO(inputTokenFIFO), outputTokenFIFO(outputTokenFIFO), input_fifos(input_fifos),
      output_fifos(output_fifos) {
}

LogicalResult BlockHandler::processFunctionAsBlocks() {
  llvm::outs() << "[BlockHandler] Processing function as unified blocks\n";

  // Phase 1: Block Analysis
  if (failed(identifyBlocksByFuncOp()))
    return failure();

  if (blocks.empty()) {
    llvm::outs() << "[BlockHandler] No blocks found in function\n";
    return success();
  }

  if (failed(analyzeCrossBlockDataflow()))
    return failure();

  // Phase 2: FIFO Infrastructure
  // Create cross-block value FIFOs (data communication)
  if (failed(createProducerFIFOs()))
    return failure();
  
  // Create intra-block coordination FIFOs (slot-to-slot within blocks)
  if (failed(createBlockTokenFIFOs()))
    return failure();
  
  // Phase 3: Block Processing (delegated to handlers)
  // Note: BlockHandler no longer generates rules directly
  // Rules are generated by BBHandler and LoopHandler
  if (failed(processAllBlocks()))
    return failure();

  return success();
}

LogicalResult BlockHandler::identifyBlocksByLoop(tor::ForOp loopOp) {
  llvm::outs() << "[BlockHandler] Identifying blocks in loop body\n";

  unsigned blockId = 0;

  // Get the loop body block from the tor::ForOp
  Block *loopBody = loopOp.getBody();
  if (!loopBody) {
    llvm::outs() << "[BlockHandler] Loop has no body block\n";
    return success();
  }

  // Debug: print loop body structure
  llvm::outs() << "[BlockHandler] Loop body has " << loopBody->getNumArguments()
               << " arguments and " << loopBody->getOperations().size() << " operations\n";

  // Process the loop body block specifically
  // This will segment the loop body based on control flow operations
  if (failed(segmentBlockIntoBlocks(loopBody, blockId))) {
    return failure();
  }

  llvm::outs() << "[BlockHandler] Identified " << blocks.size() << " blocks in loop body\n";
  return success();
}

LogicalResult BlockHandler::processLoopBodyAsBlocks(tor::ForOp loopOp) {
  llvm::outs() << "[BlockHandler] Processing loop body as unified blocks\n";

  // Phase 1: Block Analysis
  if (failed(identifyBlocksByLoop(loopOp)))
    return failure();

  if (blocks.empty()) {
    llvm::outs() << "[BlockHandler] No blocks found in function\n";
    return success();
  }

  if (failed(analyzeCrossBlockDataflow()))
    return failure();

  // Phase 2: FIFO Infrastructure
  // Create cross-block value FIFOs (data communication)
  if (failed(createProducerFIFOs()))
    return failure();
  
  // Create intra-block coordination FIFOs (slot-to-slot within blocks)
  if (failed(createBlockTokenFIFOs()))
    return failure();
  
  // Phase 3: Block Processing (delegated to handlers)
  // Note: BlockHandler no longer generates rules directly
  // Rules are generated by BBHandler and LoopHandler
  if (failed(processAllBlocks()))
    return failure();

  return success();
}

LogicalResult BlockHandler::createBlockTokenFIFOs() {
  // Create token FIFOs for cross-block coordination following Blockgen.md
  // token_fifo_b{i}_b{i+1} as specified in the documentation
  // Note: First block's input token FIFO should be provided externally

  auto &builder = mainModule->getBuilder();
  auto savedIP = builder.saveInsertionPoint();

  unifiedTokenFIFOs.clear();

  for (size_t i = 0; i + 1 < blocks.size(); ++i) {
    BlockInfo &currentBlock = blocks[i];
    BlockInfo &nextBlock = blocks[i + 1];

    auto *tokenMod = STLLibrary::createFIFO1PushModule(1, circuit);
    builder.restoreInsertionPoint(savedIP);

    // Follow Blockgen.md naming: {prefix}token_fifo_b{i}_b{i+1}
    std::string tokenName = namePrefix + "token_fifo_b" + std::to_string(currentBlock.blockId) +
                           "_b" + std::to_string(nextBlock.blockId);
    auto *tokenFIFO = mainModule->addInstance(tokenName, tokenMod,
                                              {mainClk.getValue(), mainRst.getValue()});

    unifiedTokenFIFOs[std::make_pair(currentBlock.blockId, nextBlock.blockId)] = tokenFIFO;

    // Set up unified token system using new naming convention
    currentBlock.output_token_fifo = tokenFIFO;
    nextBlock.input_token_fifo = tokenFIFO;
  }

  blocks[0].input_token_fifo = inputTokenFIFO; // the whole block's
  blocks[blocks.size() - 1].output_token_fifo = outputTokenFIFO; // same

  return success();
}

LogicalResult BlockHandler::identifyBlocksByFuncOp() {
  llvm::outs() << "[BlockHandler] Identifying blocks in function\n";

  unsigned blockId = 0;

  // Debug: print function structure
  llvm::outs() << "[BlockHandler] Function " << funcOp.getName() << " has "
               << funcOp.getBody().getBlocks().size() << " top-level blocks\n";

  // Process each basic block in the function
  for (Block &mlirBlock : funcOp.getBody().getBlocks()) {
    llvm::outs() << "[BlockHandler] Processing top-level block with " << mlirBlock.getNumArguments()
                 << " arguments and " << mlirBlock.getOperations().size() << " operations\n";
    // Now properly segment the block based on control flow operations
    if (failed(segmentBlockIntoBlocks(&mlirBlock, blockId))) {
      return failure();
    }
  }

  llvm::outs() << "[BlockHandler] Identified " << blocks.size() << " blocks\n";
  return success();
}

LogicalResult BlockHandler::analyzeCrossBlockDataflow() {
  // Analyze cross-block dataflow following Blockgen.md requirements
  // Create mapping: crossBlockEdge: (op, def_block, use_block)
  // PANIC: Ensure data integrity during analysis

  crossBlockFlows.clear();

  for (BlockInfo &producerBlock : blocks) {
    // PANIC: Ensure producer block is valid
    if (producerBlock.blockId >= blocks.size()) {
      llvm::report_fatal_error("Invalid producer block ID during dataflow analysis");
    }

    for (Value producedValue : producerBlock.producedValues) {
      // PANIC: Ensure value is valid
      if (!producedValue) {
        llvm::report_fatal_error("Null value in producer block");
      }

      // Skip virtual values that don't need FIFOs
      if (isVirtualValue(producedValue)) {
        continue;
      }

      auto consumers = findValueConsumers(producedValue);

      for (BlockInfo *consumerBlock : consumers) {
        // PANIC: Ensure consumer block is valid
        if (!consumerBlock) {
          llvm::report_fatal_error("Null consumer block during dataflow analysis");
        }

        if (consumerBlock != &producerBlock) {
          // PANIC: Ensure consumer block ID is valid
          if (consumerBlock->blockId >= blocks.size()) {
            llvm::report_fatal_error("Invalid consumer block ID during dataflow analysis");
          }

          CrossBlockValueFlow flow;
          flow.value = producedValue;
          flow.producer_block = &producerBlock;
          flow.consumer_block = consumerBlock;
          flow.fifo = nullptr; // Will be set during FIFO creation

          crossBlockFlows.push_back(flow);
        }
      }
    }
  }

  return success();
}

BlockType BlockHandler::determineBlockType(Block* block) {
  // Check for loop operations
  if (containsLoop(block)) {
    return BlockType::LOOP_HEADER;
  }

  // Check for conditional operations
  if (containsConditional(block)) {
    return BlockType::CONDITIONAL_THEN; // Will be refined later
  }

  return BlockType::REGULAR;
}

bool BlockHandler::containsLoop(Block* block) {
  return block->walk([&](tor::ForOp forOp) {
    return WalkResult::interrupt(); // Found loop
  }).wasInterrupted();
}

bool BlockHandler::containsConditional(Block* block) {
  return block->walk([&](tor::IfOp ifOp) {
    return WalkResult::interrupt(); // Found conditional
  }).wasInterrupted();
}

LogicalResult BlockHandler::segmentBlockIntoBlocks(Block *mlirBlock, unsigned &blockId) {
  // Segment block into control flow blocks following Blockgen.md requirements
  // Operations are grouped into blocks based on control flow boundaries
  llvm::SmallVector<llvm::SmallVector<Operation*, 8>> blockSegments;
  llvm::SmallVector<Operation*, 8> currentSegment;
  
  // First pass: segment operations based on control flow boundaries
  for (Operation &op : mlirBlock->getOperations()) {
    if (isa<tor::YieldOp>(&op) || isa<mlir::func::ReturnOp>(&op) || isa<tor::ReturnOp>(&op)) {
      continue; // Skip terminator operations
    }

    // Check if this operation is a control flow boundary
    if (isa<tor::ForOp>(&op) || isa<tor::IfOp>(&op) || isa<tor::WhileOp>(&op)) {
      llvm::outs() << "[BlockHandler] Found control flow op: " << op.getName() << ", currentSegment has "
                   << currentSegment.size() << " ops\n";
      // End current segment if not empty (operations BEFORE control flow)
      if (!currentSegment.empty()) {
        blockSegments.push_back(std::move(currentSegment));
        currentSegment.clear();
        llvm::outs() << "[BlockHandler] Created segment for ops before control flow\n";
      }
      // Control flow operations get their own segment
      llvm::SmallVector<Operation*, 8> controlFlowSegment;
      controlFlowSegment.push_back(&op);
      blockSegments.push_back(std::move(controlFlowSegment));
      llvm::outs() << "[BlockHandler] Created segment for control flow op\n";
      // Start new segment for operations AFTER control flow
      // (currentSegment is already empty)
    } else {
      // Regular operation - add to current segment
      currentSegment.push_back(&op);
    }
  }

  llvm::outs() << "[BlockHandler] After loop: currentSegment has " << currentSegment.size() << " ops\n";
  
  // Add final segment if not empty
  if (!currentSegment.empty()) {
    blockSegments.push_back(std::move(currentSegment));
    llvm::outs() << "[BlockHandler] Created final segment for ops after control flow\n";
  }

  llvm::outs() << "[BlockHandler] Total segments created: " << blockSegments.size() << "\n";

  // If no segments found, treat entire block as single block
  if (blockSegments.empty()) {
    std::string blockName = generateBlockName(blockId, BlockType::REGULAR);
    BlockInfo block(blockId, blockName, mlirBlock, BlockType::REGULAR);
    blocks.push_back(std::move(block));
    blockMap[blockId] = &blocks.back();
    mlirBlockMap[mlirBlock] = &blocks.back();
    blockId++;
    return success();
  }

  // Create BlockInfo for each segment with proper FIFO propagation
  for (size_t segIdx = 0; segIdx < blockSegments.size(); ++segIdx) {
    auto &segment = blockSegments[segIdx];
    if (segment.empty()) continue;

    // Determine block type based on first operation
    BlockType type = BlockType::REGULAR;
    Operation *firstOp = segment.front();

    if (isa<tor::ForOp>(firstOp)) {
      type = BlockType::LOOP_HEADER;
    } else if (isa<tor::IfOp>(firstOp)) {
      type = BlockType::CONDITIONAL_THEN;
    } else if (isa<tor::WhileOp>(firstOp)) {
      type = BlockType::LOOP_HEADER;
    }

    // Generate hierarchical block name
    std::string blockName = generateBlockName(blockId, type);
    BlockInfo block(blockId, blockName, mlirBlock, type);

    // Store the operations belonging to this segment
    for (Operation *op : segment) {
      block.operations.push_back(op);
    }

    // Analyze all operations in this segment first to populate block's operations
    for (Operation *op : segment) {
      analyzeOperationInBlock(op, block);
    }

    // Propagate input FIFOs only if the value is actually used in this segment
    // Per Blockgen.md: only pass input FIFOs that are consumed by this segment
    for (const auto &pair : input_fifos) {
        Value value = pair.first;
        Instance *fifo = pair.second;

        // Check if this value is actually used in this segment
        if (isValueUsedInBlock(value, block)) {
            block.input_fifos[value] = fifo;
            llvm::outs() << "[BlockHandler] Segment " << blockId << " uses input value, adding to input_fifos\n";
        } else {
            llvm::outs() << "[BlockHandler] Segment " << blockId << " does NOT use input value, skipping\n";
        }
    }

    // Propagate output FIFOs (these are for values this segment may produce)
    for (const auto &pair : output_fifos) {
        block.output_fifos[pair.first] = pair.second;
    }

    // Mark special block types
    if (type == BlockType::LOOP_HEADER) {
      block.is_loop_block = true;

      // For loop headers, track loop results
      if (auto forOp = dyn_cast<tor::ForOp>(segment.front())) {
        for (Value result : forOp.getResults()) {
          block.producedValues.push_back(result);
        }
      }
    }

    blocks.push_back(std::move(block));
    blockMap[blockId] = &blocks.back();
    mlirBlockMap[mlirBlock] = &blocks.back();
    blockId++;
  }

  return success();
}

LogicalResult BlockHandler::processBlock(BlockInfo& block) {
  // Process block following Blockgen.md requirements
  // PANIC: Ensure block has required FIFOs before processing

  // Check critical preconditions
  if (block.blockId >= blocks.size()) {
    llvm::report_fatal_error("Block ID out of range");
  }

  // PANIC: Ensure block type consistency
  if (block.is_loop_block && block.type != BlockType::LOOP_HEADER) {
    llvm::report_fatal_error("Block marked as loop but type is not LOOP_HEADER");
  }

  // Check if this is a loop block and handle it with LoopHandler
  if (block.is_loop_block || block.type == BlockType::LOOP_HEADER) {
    // Token FIFOs may be nullptr for top-level blocks (handled gracefully in LoopHandler)
    llvm::outs() << "[BlockHandler] Processing loop block with token FIFOs: "
                 << "input=" << (block.input_token_fifo ? "present" : "null")
                 << ", output=" << (block.output_token_fifo ? "present" : "null") << "\n";

    // Create a LoopHandler to process this loop block with proper FIFO arguments
    // Pass block's name with trailing "_" as prefix for nested components
    std::string loopPrefix = block.blockName + "_";
    LoopHandler loopHandler(pass, mainModule, funcOp, poolInstance,
                           roccInstance, hellaMemInstance, dmaItfc, circuit,
                           mainClk, mainRst, opcode, regRdInstance,
                           block.input_token_fifo, block.output_token_fifo,
                           block.input_fifos, block.output_fifos, loopPrefix);

    // Process the loop block with the LoopHandler
    if (failed(loopHandler.processLoopBlock(block))) {
      return failure();
    }

    return success();
  }

  if (block.is_conditional_block || block.type == BlockType::CONDITIONAL_THEN ||
      block.type == BlockType::CONDITIONAL_ELSE) {
    // Token FIFOs may be nullptr for top-level blocks (handled gracefully in handlers)
    llvm::outs() << "[BlockHandler] Processing conditional block with token FIFOs: "
                 << "input=" << (block.input_token_fifo ? "present" : "null")
                 << ", output=" << (block.output_token_fifo ? "present" : "null") << "\n";

    // TODO: Create ConditionalHandler for conditional blocks
    return processRegularBlockWithBBHandler(block);
  }

  // Regular block - Token FIFOs may be nullptr for top-level blocks (handled gracefully in BBHandler)
  llvm::outs() << "[BlockHandler] Processing regular block with token FIFOs: "
               << "input=" << (block.input_token_fifo ? "present" : "null")
               << ", output=" << (block.output_token_fifo ? "present" : "null") << "\n";

  return processRegularBlockWithBBHandler(block);
}

LogicalResult BlockHandler::createProducerFIFOs() {
  // Create producer FIFOs for cross-block data communication
  // Following Blockgen.md: fifo_b{i}_b{j}_{op} naming convention
  // PANIC: Ensure critical data structures are valid

  if (crossBlockFlows.empty()) {
    return success(); // No flows to process
  }

  // Counter per (producer, consumer) pair to ensure unique FIFO names for each def-use relationship
  llvm::DenseMap<std::pair<unsigned, unsigned>, unsigned> fifoCounterPerPair;

  for (CrossBlockValueFlow &flow : crossBlockFlows) {
    // PANIC: Ensure flow has valid producer and consumer blocks
    if (!flow.producer_block || !flow.consumer_block) {
      llvm::report_fatal_error("Cross-block flow has null producer or consumer block");
    }

    BlockInfo *producerBlock = flow.producer_block;
    BlockInfo *consumerBlock = flow.consumer_block;
    Value value = flow.value;

    // PANIC: Ensure producer block exists in our block list
    if (producerBlock->blockId >= blocks.size()) {
      llvm::report_fatal_error("Producer block ID out of range");
    }

    // Get and increment counter for this (producer, consumer) pair
    auto blockPair = std::make_pair(producerBlock->blockId, consumerBlock->blockId);
    unsigned counter = fifoCounterPerPair[blockPair]++;

    // Producer creates FIFO for this value with def-use naming (producer -> consumer)
    Instance* fifo = createProducerFIFO(value, producerBlock->blockId, consumerBlock->blockId, counter);

    // PANIC: Ensure FIFO creation succeeded
    if (!fifo) {
      llvm::report_fatal_error("Failed to create producer FIFO");
    }

    // Store using unified naming convention
    producerBlock->output_fifos[value] = fifo;

    // Also store in consumer's input FIFOs for easy access
    for (BlockInfo *consumerBlock : findValueConsumers(value)) {
      if (consumerBlock != producerBlock) {
        consumerBlock->input_fifos[value] = fifo;
      }
    }

    flow.fifo = fifo;
  }

  return success();
}

Instance* BlockHandler::createProducerFIFO(Value value, unsigned producerBlockId, unsigned consumerBlockId, unsigned counter) {
  auto &builder = mainModule->getBuilder();
  auto savedIP = builder.saveInsertionPoint();

  // Get bit width for FIFO sizing
  unsigned bitWidth = getBitWidth(value.getType());

  // Create FIFO module
  auto *fifoMod = STLLibrary::createFIFO1PushModule(bitWidth, circuit);
  builder.restoreInsertionPoint(savedIP);

  // Create FIFO instance with unique name reflecting def-use relationship
  // Format: {prefix}fifo_b{producer}_b{consumer}_v{counter}
  std::string fifoName = namePrefix + "fifo_b" + std::to_string(producerBlockId) +
                         "_b" + std::to_string(consumerBlockId) +
                         "_v" + std::to_string(counter);
  auto *fifoInstance = mainModule->addInstance(fifoName, fifoMod,
                                               {mainClk.getValue(), mainRst.getValue()});

  return fifoInstance;
}

llvm::SmallVector<BlockInfo*> BlockHandler::findValueConsumers(Value value) {
  llvm::SmallVector<BlockInfo*> consumers;

  for (BlockInfo &block : blocks) {
    if (isValueUsedInBlock(value, block)) {
      consumers.push_back(&block);
    }
  }

  return consumers;
}

bool BlockHandler::isValueUsedInBlock(Value value, BlockInfo& targetBlock) {
  // Check if value is used in any operation in this block
  for (Operation *user : value.getUsers()) {
    if (user->getBlock() == targetBlock.mlirBlock) {
      return true;
    }
  }
  return false;
}

bool BlockHandler::isVirtualValue(Value value) {
  // Check if this value comes from a virtual operation that doesn't need FIFO
  if (auto *defOp = value.getDefiningOp()) {
    // Virtual operations that don't represent actual data flow
    if (isa<memref::GetGlobalOp>(defOp)) {
      return true;
    }

    // Constants are also virtual
    if (isa<arith::ConstantOp>(defOp)) {
      return true;
    }

    // Memory allocation operations are virtual
    if (isa<memref::AllocOp, memref::AllocaOp>(defOp)) {
      return true;
    }
  }

  return false;
}

std::string BlockHandler::getFIFOName(StringRef prefix, unsigned blockId, StringRef suffix) {
  return std::string(prefix) + "_b" + std::to_string(blockId) + 
         (suffix.empty() ? "" : "_" + std::string(suffix));
}

unsigned BlockHandler::getBitWidth(mlir::Type type) {
  if (auto intType = dyn_cast<mlir::IntegerType>(type)) {
    return intType.getWidth();
  }
  // Default to 32 bits for unknown types
  return 32;
}

LogicalResult BlockHandler::processAllBlocks() {
  llvm::outs() << "[BlockHandler] Processing all blocks through specialized handlers\n";

  // Process each block using appropriate handler
  for (BlockInfo &block : blocks) {
    if (failed(processBlock(block))) {
      return failure();
    }
  }

  return success();
}

LogicalResult BlockHandler::processRegularBlockWithBBHandler(BlockInfo& block) {
  // Process regular block using BBHandler with proper FIFO argument handling
  // Following Blockgen.md: input_fifos and output_fifos are passed as arguments

  BBHandler bbHandler(pass, mainModule, funcOp, poolInstance, roccInstance,
                     hellaMemInstance, regRdInstance, dmaItfc, circuit, mainClk, mainRst,
                     opcode);

  // Use the new BlockInfo interface for cleaner API and proper blockName access
  return bbHandler.processBasicBlock(block);
}


void BlockHandler::analyzeOperationInBlock(Operation *op, BlockInfo &block) {
  // Analyze operation within a block following Blockgen.md requirements
  // Track timing, produced values, and consumed values for data dependency analysis

  // Skip tor.timegraph operations - they are metadata and shouldn't affect block timing
  if (isa<tor::TimeGraphOp>(op)) {
    return;
  }

  // Track timing
  if (auto startAttr = op->getAttrOfType<IntegerAttr>("starttime")) {
    int64_t startTime = startAttr.getInt();
    if (block.startTime == -1 || startTime < block.startTime) {
      block.startTime = startTime;
    }
  }

  if (auto endAttr = op->getAttrOfType<IntegerAttr>("endtime")) {
    int64_t endTime = endAttr.getInt();
    if (endTime > block.endTime) {
      block.endTime = endTime;
    }
  }

  // Special handling for interface operations - don't track their tokens as cross-block values
  if (isa<aps::ItfcBurstLoadReq, aps::ItfcBurstStoreReq, aps::ItfcLoadReq, aps::ItfcStoreReq>(op)) {
    // Don't track the request token as a produced value - it should only be consumed locally
    return;
  }

  // Special handling for interface collect operations - they don't produce values for cross-block flow
  if (isa<aps::ItfcBurstLoadCollect, aps::ItfcBurstStoreCollect, aps::ItfcLoadCollect, aps::ItfcStoreCollect>(op)) {
    // Collect operations don't produce values that flow to other blocks
    return;
  }

  // Track produced values, but skip virtual operations
  if (isa<memref::GetGlobalOp, arith::ConstantOp, memref::AllocOp, memref::AllocaOp>(op)) {
    // Virtual operations don't need cross-block FIFOs
  } else {
    // Track produced values for non-virtual operations
    for (Value result : op->getResults()) {
      block.producedValues.push_back(result);
    }
  }

  // Track consumed values (from other blocks)
  for (Value operand : op->getOperands()) {
    if (auto *defOp = operand.getDefiningOp()) {
      if (defOp->getBlock() != block.mlirBlock) {
        block.consumedValues.push_back(operand);
      }
    } else if (auto blockArg = dyn_cast<BlockArgument>(operand)) {
      if (blockArg.getOwner() != block.mlirBlock) {
        block.consumedValues.push_back(operand);
      }
    }
  }
}

std::string BlockHandler::generateBlockName(unsigned blockId, BlockType type, const std::string& parentName) {
  std::string baseName;

  // Generate base name based on block type
  switch (type) {
    case BlockType::REGULAR:
      baseName = "block_" + std::to_string(blockId);
      break;
    case BlockType::LOOP_HEADER:
      baseName = "loop_" + std::to_string(blockId);
      break;
    case BlockType::CONDITIONAL_THEN:
      baseName = "if_then_" + std::to_string(blockId);
      break;
    case BlockType::CONDITIONAL_ELSE:
      baseName = "if_else_" + std::to_string(blockId);
      break;
    case BlockType::CONDITIONAL_EXIT:
      baseName = "if_exit_" + std::to_string(blockId);
      break;
    default:
      baseName = "block_" + std::to_string(blockId);
      break;
  }

  // If parent name is provided, create hierarchical name
  if (!parentName.empty()) {
    return parentName + baseName;
  }

  // Use namePrefix from constructor (includes opcode)
  return namePrefix + baseName;
}

} // namespace mlir