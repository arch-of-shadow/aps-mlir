#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static matrix: [i32; 16];

#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static vec: [i32; 4];

#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static result: [i32; 4];

static acc: i32;
// VGEMV3D.VV - Vector-Vector mode
// Multiplies 4Ã—4 matrix with 4D homogeneous vector
#[opcode(7'b0101011)]
#[funct7(7'b0110001)]
rtype vgemv3d_vv(rs1: u5, rs2: u5, rd: u5) {
  let addr: u32 = _irf[rs1];   
  let out_addr: u32 = _irf[rs2];   
  matrix[0 +: ] = _burst_read[addr +: 16];
  vec[0 +: ] = _burst_read[addr + 64 +: 4];
  with i: u32 = (0, i_) do {
    let i_mul_2: u32 = i * 2;
    acc = 0;
    [[unroll(4)]]
    with j: u32 = (0, j_) do {
      acc = acc + matrix[i_mul_2 * 4 + j] * vec[j];
      let j_: u32 = j + 1;
    } while (j_ < 4);
    result[i_mul_2] = acc;
    acc = 0;
    [[unroll(4)]]
    with j: u32 = (0, j_) do {
      acc = acc + matrix[(i_mul_2 + 1) * 4 + j] * vec[j];
      let j_: u32 = j + 1;
    } while (j_ < 4);
    result[i_mul_2 + 1] = acc;
    let i_: u32 = i + 1;
  } while (i_ < 2);
  _burst_write[out_addr +: 4] = result[0 +: ];
  _irf[rd] = 0;
}
