// GELU - Gaussian Error Linear Unit (Approximate Version)
// Formula: gelu(x) ≈ x * sigmoid(1.702 * x)
// Where sigmoid(y) = 1 / (1 + exp(-y))
//
// This is a fast approximation commonly used in practice.

// ============================================================================
// Memory Buffers
// ============================================================================

#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static input_mat: [u32; 16];

#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static output_mat: [u32; 16];

// ============================================================================
// GELU Kernel (Approximate Version using Sigmoid)
// ============================================================================

#[opcode(7'b0001011)]
#[funct7(7'b0101110)]
rtype gelu_approx_4x4(rs1: u5, rs2: u5, rd: u5) {
    let addr_in: u32 = _irf[rs1];
    let addr_out: u32 = _irf[rs2];

    input_mat[0 +: ] = _burst_read[addr_in +: 32];

    // Constants
    // 1.702f = 0x3FDA1CAC, 1.0f = 0x3F800000, 0.0f = 0x00000000
    let coeff_bits: u32 = 1071259820;
    let one_bits: u32 = 1065353216;
    let zero_bits: u32 = 0;

    let coeff: f32 = bitcast<f32>(coeff_bits);
    let one: f32 = bitcast<f32>(one_bits);
    let zero: f32 = bitcast<f32>(zero_bits);

    [[unroll(4)]]
    with i: u32 = (0, i_) do {
        let bits: u32 = input_mat[i];
        let x: f32 = bitcast<f32>(bits);

        // sigmoid(1.702 * x) = 1 / (1 + exp(-1.702 * x))
        let scaled: f32 = coeff * x;
        let neg_scaled: f32 = zero - scaled;
        let exp_neg: f32 = exp(neg_scaled);
        let sigmoid_val: f32 = one / (one + exp_neg);

        // gelu(x) ≈ x * sigmoid(1.702 * x)
        let result: f32 = x * sigmoid_val;

        output_mat[i] = bitcast<u32>(result);
        let i_: u32 = i + 1;
    } while (i_ < 16);

    _burst_write[addr_out +: 32] = output_mat[0 +: ];
    _irf[rd] = 0;
}
