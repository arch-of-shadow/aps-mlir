// RMSNorm - Root Mean Square Layer Normalization
// Formula: rmsnorm(x) = x / sqrt(mean(x²) + ε)
//
// Simpler and faster than LayerNorm (no mean subtraction).
// Used in LLaMA and other modern LLMs.

// ============================================================================
// Memory Buffers
// ============================================================================

#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static input_mat: [u32; 16];

#[partition_dim_array([0])]
#[partition_factor_array([4])]
#[partition_cyclic_array([1])]
static output_mat: [u32; 16];

// ============================================================================
// RMSNorm Kernel
// ============================================================================

#[opcode(7'b0001011)]
#[funct7(7'b0110000)]
rtype rmsnorm_4x4(rs1: u5, rs2: u5, rd: u5) {
    let addr_in: u32 = _irf[rs1];
    let addr_out: u32 = _irf[rs2];

    input_mat[0 +: ] = _burst_read[addr_in +: 32];

    // Constants: 0.25f = 0x3E800000, epsilon = 1e-5 = 0x3727C5AC
    let quarter_bits: u32 = 1048576000;
    let epsilon_bits: u32 = 922818988;

    let quarter: f32 = bitcast<f32>(quarter_bits);
    let epsilon: f32 = bitcast<f32>(epsilon_bits);

    // Process row by row
    with row: u32 = (0, row_) do {
        let row_base: u32 = row * 4;

        let idx0: u32 = row_base;
        let idx1: u32 = row_base + 1;
        let idx2: u32 = row_base + 2;
        let idx3: u32 = row_base + 3;

        let bits0: u32 = input_mat[idx0];
        let bits1: u32 = input_mat[idx1];
        let bits2: u32 = input_mat[idx2];
        let bits3: u32 = input_mat[idx3];

        let v0: f32 = bitcast<f32>(bits0);
        let v1: f32 = bitcast<f32>(bits1);
        let v2: f32 = bitcast<f32>(bits2);
        let v3: f32 = bitcast<f32>(bits3);

        // Compute mean(x²) = (x0² + x1² + x2² + x3²) / 4
        let sq0: f32 = v0 * v0;
        let sq1: f32 = v1 * v1;
        let sq2: f32 = v2 * v2;
        let sq3: f32 = v3 * v3;

        let sum_sq: f32 = sq0 + sq1 + sq2 + sq3;
        let mean_sq: f32 = sum_sq * quarter;

        // Compute 1/sqrt(mean_sq + epsilon)
        let rms: f32 = sqrt(mean_sq + epsilon);

        // Normalize: y = x / rms
        let r0: f32 = v0 / rms;
        let r1: f32 = v1 / rms;
        let r2: f32 = v2 / rms;
        let r3: f32 = v3 / rms;

        output_mat[idx0] = bitcast<u32>(r0);
        output_mat[idx1] = bitcast<u32>(r1);
        output_mat[idx2] = bitcast<u32>(r2);
        output_mat[idx3] = bitcast<u32>(r3);

        let row_: u32 = row + 1;
    } while (row_ < 4);

    _burst_write[addr_out +: 32] = output_mat[0 +: ];
    _irf[rd] = 0;
}
